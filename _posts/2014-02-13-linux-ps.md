---
layout: post
title: Linux进程管理
tags: Linux 进程管理
categories: Linux
published: false
---


* TOC 
{:toc}

## `&`


**将命令放在后台运行**

command &

此时将会产生1个任务编号与一个PID，命令执行完成后将会在前台出现提示

>后台执行的任务如果存在信息输出，最好将其写入到文件，否则将会在前台显示，影响操作

---

## `[ctrl]-z`

**将命令放在后台暂停**

此时将会产生1个任务编号及其命令

---

## `jobs`

**查看后台任务状态**

[root@www ~]#  `jobs [-lrs]`

选项与参数：

`-l`  ：除了列出 job number 与命令串之外，同时列出 PID 的号码；

`-r`  ：仅列出正在背景 run 的工作；

`-s`  ：仅列出正在背景当中暂停 (stop) 的工作。

>`+` 代表最近被放到背景的工作号码， `-` 代表最近最后第二个被放置到背景中的工作号码，其余没有符号

---

## `fg`

**将后台任务放到前台**

[root@www ~]#  `fg %jobnumber`

选项与参数：

`%jobnumber` ：jobnumber 为任务号码(数字)，那个 % 是可有可无的！

---

## `bg`

**将后台暂停的任务变为运行中**

[root@www ~]#  `bg %jobnumber` 

---

## `kill`

**移除任务**

[root@www ~]# `kill -signal %jobnumber`

[root@www ~]# `kill -l`

选项与参数：

`-l`  ：这个是 L 的小写，列出目前 kill 能够使用的讯号 (signal) 有哪些

`signal` ：代表给予后面接的那个工作什么样的指示罗！用 man 7 signal 可知：

>  `-1` ：重新读取一次参数的配置档 (类似 reload)；
>
>  `-2` ：代表与由键盘输入 [ctrl]-c 同样的动作；
>
>  `-9` ：立刻强制删除一个工作；
>
>  `-15`：以正常的程序方式终止一项工作。与 -9 是不一样的。

---

## `nohup`

**离线任务**

>`!特别说明` 前面的几个命令中所谓的"背景”，都是指终端机背景(不会被ctrl+c中断)，并非系统背景，一旦退出终端，任务立即终止。`nohup`可以在退出终端后继续执行任务。

[root@www ~]#  `nohup` [命令与参数]   <==在终端机前台中工作

[root@www ~]#  `nohup` [命令与参数] & <==在终端机后台中工作

---

## `pstree`

**显示进程树**

[root@www ~]#  `pstree [-A|U] [-up]`

选项与参数：

`-A`  ：各程序树之间的连接以 ASCII 字节来连接；

`-U`  ：各程序树之间的连接以万国码的字节来连接。在某些终端介面下可能会有错误；

`-p`  ：并同时列出每个 process 的 PID；

`-u`  ：并同时列出每个 process 的所属帐号名称。

---

## `ps` 

**将某个时间点的程序运行情况撷取下来**

[root@www ~]#  `ps aux`  <==观察系统所有的程序数据

[root@www ~]#  `ps -lA`  <==也是能够观察所有系统的数据

[root@www ~]#  `ps axjf` <==连同部分程序树状态

选项与参数：

`-A`  ：所有的 process 均显示出来，与 -e 具有同样的效用；

`-a`  ：不与 terminal 有关的所有 process ；

`-u`  ：有效使用者 (effective user) 相关的 process ；

`x`   ：通常与 a 这个参数一起使用，可列出较完整资讯。

输出格式规划：

`l`   ：较长、较详细的将该 PID 的的资讯列出；

`j`   ：工作的格式 (jobs format)

`-f`  ：做一个更为完整的输出。

---

### `ps -l`

**仅观察自己的 bash 相关程序**

`F`：代表这个程序旗标 (process flags)，说明这个程序的总结权限，常见号码有：

>若为 `4` 表示此程序的权限为 root ；
>
>若为 `1` 则表示此子程序仅进行复制(fork)而没有实际运行(exec)。

`S`：代表这个程序的状态 (STAT)，主要的状态有：

>`R` (Running)：该程序正在运行中；
>
>`S` (Sleep)：该程序目前正在睡眠状态(idle)，但可以被唤醒(signal)。
>
>`D` ：不可被唤醒的睡眠状态，通常这支程序可能在等待 I/O 的情况(ex>列印)
>
>`T` ：停止状态(stop)，可能是在工作控制(背景暂停)或除错 (traced) 状态；
>
>`Z` (Zombie)：僵尸状态，程序已经终止但却无法被移除至内存外。

`UID/PID/PPID`：代表此程序被该 UID 所拥有/程序的 PID 号码/此程序的父程序 PID 号码

`C`：代表 CPU 使用率，单位为百分比

`PRI/NI`：Priority/Nice 的缩写，代表此程序被 CPU 所运行的优先顺序，数值越小代表该程序越快被 CPU 运行

`ADDR/SZ/WCHAN`：都与内存有关，ADDR 是 kernel function，指出该程序在内存的哪个部分，如果是个 running 的程序，一般就会显示『 - 』 / SZ 代表此程序用掉多少内存 / WCHAN 表示目前程序是否运行中，同样的， 若为 - 表示正在运行中。

`TTY`：登陆者的终端机位置，若为远程登陆则使用动态终端介面 (pts/n)；

`TIME`：使用掉的 CPU 时间，注意，是此程序实际花费 CPU 运行的时间，而不是系统时间；

`CMD`：就是 command 的缩写，造成此程序的触发程序之命令为何

---

### `ps aux`

**观察系统所有程序**

`USER`：该 process 属於那个使用者帐号的？

`PID` ：该 process 的程序识别码。

`%CPU`：该 process 使用掉的 CPU 资源百分比；

`%MEM`：该 process 所占用的实体内存百分比；

`VSZ` ：该 process 使用掉的虚拟内存量 (Kbytes)

`RSS` ：该 process 占用的固定的内存量 (Kbytes)

`TTY` ：该 process 是在那个终端机上面运行，若与终端机无关则显示 ?，另外， tty1-tty6 是本机上面的登陆者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。

`STAT`：该程序目前的状态，状态显示与 ps -l 的 S 旗标相同 (R/S/T/Z)

`START`：该 process 被触发启动的时间；

`TIME` ：该 process 实际使用 CPU 运行的时间。

`COMMAND`：该程序的实际命令为何？

>ps结果后接 `<defunct>` 表示为僵尸程序

---

## `top` 

**动态观察程序的变化**

[root@www ~]#  `top [-d 数字] | top [-bnp]`

选项与参数：

`-d`  ：后面可以接秒数，就是整个程序画面升级的秒数。默认是 5 秒；

`-b`  ：以批量的方式运行 top ，还有更多的参数可以使用，通常会搭配数据流重导向来将批量的结果输出成为文件。

`-n`  ：与 -b 搭配，意义是，需要进行几次 top 的输出结果。

`-p`  ：指定某些个 PID 来进行观察监测。

在 top 运行过程当中可以使用的按键命令：

`?` ：显示在 top 当中可以输入的按键命令；

`P`：以 CPU 的使用资源排序显示；

`M` ：以 Memory 的使用资源排序显示；

`N` ：以 PID 来排序喔！

`T` ：由该 Process 使用的 CPU 时间累积 (TIME+) 排序。

`k` ：给予某个 PID 一个讯号  (signal)

`r` ：给予某个 PID 重新制订一个 nice 值。

`q` ：离开 top 软件的按键。

---

**`echo $$`** ( 查看bash的pid)

---

## `signal`

| 代号 | 名称 | 内容 |
|:----:|:----:|:----|
| 1 | SIGHUP | 启动被终止的程序,可让该 PID 重新读取配置,类似重新启动 |
| 2 | SIGINT | 相当於用键盘输入 [ctrl]-c 来中断一个程序 |
| 9 | SIGKILL | 强制中断一个程序，尚未完成的部分可能会有遗留物|
| 15	 | SIGTERM |	正常结束程序,如果该程序已经发生问题,signal将失效 |
| 17 | SIGSTOP | 相当於用键盘输入 [ctrl]-z 来暂停一个程序 |

---

## `kill`

**杀死进程**

[root@www ~]# `kill PID`

`!特别说明`：kill后面直接加数字表示杀死进程，这与上面的移除任务用法是不同的

---

## `killall`

**按程序启动命令杀死进程**

[root@www ~]# ` killall [-iIe] [command name]`

选项与参数：

`-i`  ：interactive 互动的意思，删除时，会出现提示

`-e`  ：exact 准确的意思，后面接的 command name要与运行中程序的启动命令一致，但整个完整的命令不能超过 15 个字节(若程序启动时使用了参数，则程序名与后面接的参数作为整体)

`-I` ：命令名称(可能含参数)忽略大小写。  


---

## `nice`

**指定nice值启动新程序**

[root@www ~]#  `nice [-n 数字] command`

选项与参数：

`-n`  ：后面接一个数值，数值的范围 -20 ~ 19。

---

## `renice`

**重设指定程序的nice值**

[root@www ~]#  `renice [number] PID`

选项与参数：

`PID` ：某个程序的 ID 
 
---

## `free`

**观察内存使用情况**

[root@www ~]#  `free [-b|-k|-m|-g] [-t]`

选项与参数：

默认单位为 Kbytes，可以使用 `-b`(bytes),`-m`(Mbytes),`-k`(Kbytes),`-g`(Gbytes) 来显示单位

`-t` ：显示实体内存与 swap 的总量。

---

## `uname`

**查看系统核心信息**

[root@www ~]#  `uname [-asrmpi]`

选项与参数：

`-a`  ：所有系统相关的资讯，包括底下的数据都会被列出来；

`-s`  ：系统核心名称

`-r` ：核心的版本

`-m`  ：本系统的硬件名称，例如 i686 或 x86_64 等；

`-p`  ：CPU 的类型，与 -m 类似，只是显示的是 CPU 的类型！

`-i`  ：硬件的平台 (ix86)

---

## `uptime`

**观察系统启动时间与工作负载**


---

## `netstat`

**追踪网络与Socket**

[root@www ~]#  `netstat -[atunlp]`

选项与参数：

`-a`  ：将目前系统上所有的连线、监听、Socket 数据都列出来

`-t`  ：列出 tcp 网络封包的数据

`-u`  ：列出 udp 网络封包的数据

`-n`  ：不以程序的服务名称，以端口号 (port number) 来显示；

`-l` ：列出目前正在网络监听 (listen) 的服务；

`-p` ：列出该网络服务的程序 PID 


网络参数

`Proto` ：网络的封包协议，主要分为 TCP 与 UDP 封包，相关数据请参考服务器篇；

`Recv-Q`：非由使用者程序连结到此 socket 的复制的总 bytes 数；

`Send-Q`：非由远程主机传送过来的 acknowledged 总 bytes 数；

`Local Address` ：本地端的 IP:port 情况

`Foreign Address`：远程主机的 IP:port 情况

`State` ：连线状态，主要有创建(ESTABLISED)及监听(LISTEN)；

本机程序

`Proto` ：一般就是 unix 啦；

`RefCnt`：连接到此 socket 的程序数量；

`Flags` ：连线的旗标；

`Type` ：socket 存取的类型。主要有确认连线的 STREAM 与不需确认的 DGRAM 两种；

`State` ：若为 CONNECTED 表示多个程序之间已经连线创建。

`Path` ：连接到此 socket 的相关程序的路径！或者是相关数据输出的路径。

---

## `dmesg`

**查看核心产生的信息**

---

## `vmstat`

**侦测系统资源变化**

[root@www ~]#  `vmstat [-a] [间隔时间] [总次数]]` <==CPU/内存等资讯

[root@www ~]# ` vmstat [-fs]`                    <==内存相关

[root@www ~]#  `vmstat [-S 单位]`                 <==配置显示数据的单位

[root@www ~]#  `vmstat [-d]`                       <==与磁碟有关

[root@www ~]#  `vmstat [-p 分割槽]`                <==与磁碟有关

选项与参数：

`-a`  ：使用 inactive/active(活跃与否) 取代 buffer/cache 的内存输出资讯；

`-f`  ：启动到目前为止，系统复制 (fork) 的程序数；

`-s`  ：将一些事件 (启动至目前为止) 导致的内存变化情况列表说明；

`-S`  ：后面可以接单位，让显示的数据有单位。例如 K/M 取代 bytes 的容量；

`-d`  ：列出磁碟的读写总量统计表

`-p`  ：后面列出分割槽，可显示该分割槽的读写总量统计表

>内存栏位 (`procs`) 的项目分别为：

>>`r` ：等待运行中的程序数量；`b`：不可被唤醒的程序数量。这两个项目越多，代表系统越忙碌 (因为系统太忙，所以很多程序就无法被运行或一直在等待而无法被唤醒之故)。

>内存栏位 (`memory`) 项目分别为：

>>`swpd`：虚拟内存被使用的容量； `free`：未被使用的内存容量； `buff`：用於缓冲内存； `cache`：用於高速缓存。 这部份则与 `free` 是相同的。

>内存置换空间 (`swap`) 的项目分别为：

>>`si`：由磁碟中将程序取出的量； `so`：由於内存不足而将没用到的程序写入到磁碟的 `swap` 的容量。 如果 si/so 的数值太大，表示内存内的数据常常得在磁碟与主内存之间传来传去，系统效能会很差！

>磁碟读写 (`io`) 的项目分别为：

>>`bi`：由磁碟写入的区块数量； `bo`：写入到磁碟去的区块数量。如果这部份的值越高，代表系统的 I/O 非常忙碌！
    
>系统 (`system`) 的项目分别为：

>>`in`：每秒被中断的程序次数； `cs`：每秒钟进行的事件切换次数；这两个数值越大，代表系统与周边设备的沟通非常频繁！ 这些周边设备当然包括磁碟、网络卡、时间钟等。

>`CPU` 的项目分别为：

>>`us`：非核心层的 CPU 使用状态； `sy`：核心层所使用的 CPU 状态； `id`：闲置的状态； `wa`：等待 I/O 所耗费的 CPU 状态； `st`：被虚拟机器 (virtual machine) 所盗用的 CPU 使用状态 (2.6.11 以后才支持)。

---

## `fuser`

**查看使用指定的文件或文件系统的进程**

[root@www ~]#  `fuser [-umv] [-k [i] [-signal]]` file/dir

选项与参数：

`-u` ：除了程序的 PID 之外，同时列出该程序的拥有者；

`-m`  ：后面接的那个档名会主动的上提到该文件系统的最顶层，对 umount 不成功很有效！

`-v`  ：可以列出每个文件与程序还有命令的完整相关性！

`-k`  ：找出使用该文件/目录的 PID ，并试图以 SIGKILL 这个讯号给予该 PID；

`-i`  ：必须与 -k 配合，在删除 PID 之前会先询问使用者意愿！

`-signal`：例如 -1 -15 等等，若不加的话，默认是 SIGKILL (-9) 罗！

>权限:

`c` ：此程序在当前的目录下(非次目录)；

`e` ：可被触发为运行状态；

`f` ：是一个被开启的文件；

`r` ：代表顶层目录 (root directory)；

`F` ：该文件被开启了，不过在等待回应中；

`m` ：可能为分享的动态函式库；

---

## `lsof`

**列出由程序开启的文件**

[root@www ~]#  `lsof [-aUu] [+d]`

选项与参数：

`-a`  ：多项数据需要『同时成立』才显示出结果时！（内连接`？`）

`-U`  ：仅列出 Unix like 系统的 socket 文件类型；

`-u`  ：后面接 username，列出该使用者相关程序所开启的文件；

`+d`  ：后面接目录，即找出某个目录底下已经被开启的文件！

---

## `pidof`

**找出某个正在的运行程序的pid**

[root@www ~]#  `pidof [-sx] program_name...`

选项与参数：

`-s`  ：仅列出一个 PID 而不列出所有的 PID

`-x`  ：同时列出该 program name 可能的 PPID 那个程序的 PID

