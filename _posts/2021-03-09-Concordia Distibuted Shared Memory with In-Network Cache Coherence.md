---
title: Concordia:Distributed Shared Memory with In-Network Cache Coherence
tags: 
- tag: Cache
- tag: Cache Coherence
- tag: RDMA
- tag: KVS
- tag: 可编程交换机
categories: FAST
author: 李之悦
---

这篇文章主要讲述了如何利用带有计算与存储能力的可编程交换机(programmable switch)，来降低较小的集群规模(rack范围内)中分布式Cache的一致性维护开销，提高系统性能。该工作是由清华大学高性能计算所舒继武、陆游游老师团队完成的，第一作者为博士生汪庆。

## 问题背景

分布式共享内存(distributed shared memory, DSM)可以将分布式集群memory向上抽象成线性而统一的地址空间，方便上层分布式应用的编程，然而其性能却受制于网络带宽与延迟。在DSM上做一层分布式缓存可以有效的提高DSM的性能，但是维护缓存一致性会带来较大的开销。在写无效的一致性协议中，写者需要追踪数据副本所在节点，并发出无效化信号。根据追踪数据副本的方式不同，有两种常用的一致性协议，分别是基于目录的一致性协议以及基于监听的一致性协议。两种协议各有优缺点：前者的无效化信息传输延迟较高，而后者可能会造成网络带宽与CPU资源的浪费。Concordia兼顾了两者的优点，利用可编程交换机的计算与存储能力，在基于目录的一致性协议上，实现了高效的分布式缓存一致性管理。简单的说，本文的思路是让带有计算和存储能力的交换机作为一个节点，存储热点数据的目录以及读写锁，从而免去了对目录节点的访问。

## 挑战

实现上述思路存在三点主要挑战：
- 交换机有限的计算能力：相比于server节点，交换机能够处理的逻辑比较简单，然而缓存一致性维护包括状态机转化等问题，其逻辑比较复杂，需要考虑交换机与server节点之间的任务分配。
- 交换机有限的存储能力：交换机的存储能力有限(约几MB)，面对TB量级的数据，需要考虑如何有效管理。
- 交换机的有状态性质：由于交换机内部存有读写锁，也就是说交换机是一个有状态的网络设备，网络超时重传可能会导致系统逻辑混乱。

## 解决方法

Concorida面对上面三个挑战，提出了三个主要的技术点：
- 针对计算能力有限的问题，Concordia将一次完整的cache一致性协议维护流程分担给server与交换机共同完成，其中逻辑比较简单、但是在关键路径上的部分交给交换机，如持锁以及无效数据的多播，而逻辑比较复杂，但是可以异步完成(即不在关键路径上)的部分交给server，如一次无效化完成之后数据状态的转化，就可以由server异步的发给交换机，以更新其状态。
- 针对存储能力有限的问题，Concorida的解决方法非常直观，即只存储少数热点数据的目录在交换机中，并向上提供迁移数据目录的接口。数据的热度可能会随时间变化而变化，因此Concordia会令交换机与server按时间片追踪数据的热度信息，并汇总给与交换机连接的shadow node，来决定下一个时间片内哪些数据应当换入交换机，哪些数据应当换出。
- 交换机有状态，带来的问题就是如果网络因为超时而产生重传，但是最终却有两个数据包都抵达了目的地(交换机、server)，就可能会引起逻辑错误，比如对交换机来说可能会多次放锁引起死锁。之所以会出现这个现象，是由于交换机工作的网络层上并没有机制过滤掉重复发送的数据包。解决方法也非常简单，即自己加入一个去重逻辑，通过对消息编号，实现能够去重的幂等操作。

## 实验结果

实验部分与之前的两个DSM工作GAM(有分布式cache)以及Grappa(无分布式cache)做了对比，测量了在三种场景：micro-benchmark、事务处理以及图计算下的性能表现，主要考察的指标有系统吞吐量、网络占用情况以及故障恢复等指标。详细实验结果请参考论文。

 
了解更多请关注: [论文原文及ppt](https://www.usenix.org/conference/fast21/presentation/wang) 