---
title: RackSched:A Microsecond-Scale Scheduler for Rack-Scale Computers
tags: 
  - tag: programmable switch
  - tag: scheduling
  - tag: microsend-scale service
categories: OSDI
author: 李之悦
---
## 问题背景
本文针对数据中心内有微秒级延迟要求的服务，考虑如何将一个机架范围（rack-scale）内的机器抽象成一个大的机器，为上层应用提供微秒级延迟的服务。

数据中心的许多应用，如KV存储、事务处理以及网络查询等应用，要求在设备这一层的尾延迟在微秒量级（几十~几百微秒），这样才能让服务的总延迟控制在毫秒量级，给用户更好的体验。

已有工作已经做了单个机器内微秒级的任务调度（shinjuku， NSDI’19），而随着应用规模的不断扩大，单机内多核的scale-up已经不能满足应用的要求，scale-out到多台机器成为现在数据中心的一个趋势。

然而，同时满足高吞吐与低延迟是一个挑战。本工作借助可编程交换机，在其数据平面实现了负载追踪、任务调度等功能，实现机架范围内的快速调度，达到高吞吐、低处理尾延迟的目的。

## 尾延迟的来源

任务调度中引起尾延迟有两个重要的因素，head-of-line blocking和load imbalance。

- head-of-line blocking：对于执行时间差别很大的任务，如果长执行时间的任务被调度到短执行时间任务的前面，就会导致短执行时间的进程出现latency spike，进而导致尾延迟的增加。不同任务之间的快速、高效抢占可以解决这个问题。
- load imbalance：对于有多个处理队列的调度系统，如果不同队列被分发的任务量有较大差别，会导致负载不均而引起较高的排队延迟，反映在系统上就是相同的压力下尾延迟更大。一个中心化的调度队列可以解决这个问题。

在单机场景中，shinjuku已经很好的解决了这两个问题，本文是在一个机架范围内的多机场景下解决这两个问题。

## 两层调度架构
针对rack-scale的机器中几百-几千个核调度困难、单一调度核/机器会成为瓶颈的问题，RackSched借助可编程交换机能够以line-rate处理数据的特点，以及能够在上面搭载一定逻辑的功能，在数据平面实现了高效的任务调度。

<div align=center>
<img src="\assets\img\papers\2021-06-01\img1.png">
</div>

RackSched将任务调度分为两层，提出了上图所示的hierarchical scheduling的方法，将每一个任务调度分成两部分：机器之间的第一层调度以及机器内的第二层调度，并向用户提供的还是一个大机器抽象的接口。机器之间的调度通过可编程交换机的逻辑处理实现，以解决不同机器之间load imbalance的问题；而机器内的调度则直接套用Shinjuku的调度方法，解决单个机器内head-of-line blocking的问题。

## 调度方式
本文的主要工作集中于inter-server scheduling上。可编程交换机为每一个server维护了一个变量，存储某一个时刻的队列深度。该队列深度由server返回的ACK包异步更新。调度采用最简单的join-the-shortest-queue策略，每一个新到达交换机的包都会选择队列长度最短的节点作为目的地。

在搜索队列最短的server时，考虑到可编程交换机同一stage不能处理有依赖的请求，进行了基于树结构的并行化操作。

## 其它问题
- 聚集效应（herding）：由于racksced会异步更新队列深度，在相邻两次更新的间隔内，多个到达时间相近的请求会同时发送到一个节点，造成一个burst。为了避免这样的情况，racksched对调度进行了一定的改进，引入了power-of-k的机制，该方法会先随机选取k个节点，再从其中选取一个队列长度最短的节点作为目标节点，这样相邻的请求就有很大概率不会发到同一节点，避免了herding的问题。
- 亲和性（affinity）：某些请求可能会有亲和性的需求，如某些请求之间存在输入输出的依赖，必须发到同一个节点上。RackSched并非静态调度方法，不能保证相同request ID的请求调度到同一节点。为此RackSched在交换机中维护了一个保证亲和性的哈希表，以请求的request ID作为哈希键，以第一个请求被调度到的节点IP作为值，保证相同request ID的请求会被调度到同一节点。

## 实验
实验在12台机器组成的机架中进行，其中四台作为客户端，八台作为服务器。性能方面的评测包括处理请求的延迟与吞吐量，测试的负载包扩各种分布的模拟负载以及真实的负载RocksDB。

对于基本性能的对比，包含同构比较与异构比较两个部分。所谓同构比较，即每个server用于处理请求的核数是相同的。在不同负载轻重下（体现在吞吐量高低），已经能够得出RackSched比Shinjuku的效果要好。所谓异构比较，指八台server中有一半的只使用4个核，另一半使用7个核，来模拟处理能力不均衡的情况。这种情况下，RackSched的效果更明显，同样latency下最大有1.44倍的吞吐量提升。在真实负载RocksDB上的测试结果也表明，RackSched有比Shinjuku更低的尾延迟。

文章还测量了RackSched的不同模块是否选用了最优策略，考虑了不同的交换机选择策略、不同的负载追踪策略以及不同的任务调度策略之间的对比，发现RackSched在各个模块中采取的策略都是最优的。